% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/markov_model.R
\name{mldpEHR.mortality_markov}
\alias{mldpEHR.mortality_markov}
\title{build a Markov probability model from multi-age prediction models
To implement this, all patients at a given age will be binned according to their model score (using quantiles).
Each bin is assigned a state, and we are computing the probability for traversing from each state to the next model state'}
\usage{
mldpEHR.mortality_markov(
  models,
  follow_time,
  outcome,
  step,
  qbins = seq(0, 1, by = 0.05)
)
}
\arguments{
\item{models}{\itemize{
\item list of prediction models (output of build_cross_validation_time_stitch_classification_models)
}}

\item{follow_time}{\itemize{
\item list of data.frames per age, defining for each patient how much follow-up time they had. Dataframe must include the following columns:
\item id
\item time_in_system
\item target_class - the classification if known for outcome years or within step (i.e. patient died). NA for unknown step outcome.
}}

\item{outcome}{\itemize{
\item time from oldest model (first) to target outcome
}}

\item{step}{\itemize{
\item time between prediction models
}}

\item{qbins}{\itemize{
\item quantile bin size of prediction score for which the markov model will define a state
}}
}
\value{
a list of markov models (per age), each is a list with the following members:
\itemize{
\item model - matrix containing the probability for each quantile(score) bin to reach each of the target_classes provided in the oldest model.
\item local.model - data.frame containing the probability for each quantile(score) bin to reach each of the quantile(score) bins of the next model by age.
\item qbins -  bins
\item target - data frame containing the target bin for this age model (to be used as outcome for the younger age model)
}
}
\description{
build a Markov probability model from multi-age prediction models
To implement this, all patients at a given age will be binned according to their model score (using quantiles).
Each bin is assigned a state, and we are computing the probability for traversing from each state to the next model state'
}
\examples{

library(dplyr)
library(ggplot2)
# build base predictor
target <- data.frame(id = 1:1000, target_class = rep(c(0, 1), each = 500), sex = rep(0:1, 500))
features <- data.frame(id = 1:500, a = rnorm(500), b = rnorm(500)) \%>\%
    bind_rows(
        data.frame(id = 501:1000, a = rnorm(500, mean = 2, sd = 2), b = rnorm(500, mean = -2, sd = 2))
    )
predictor <- mldpEHR.cv_train_outcome(target, features, folds = 3)
target_list <- purrr::map(1:3, ~ data.frame(id = 1:1000, target_class = NA, sex = rep(0:1, 500))) \%>\% setNames(1:3)
feature_list <- purrr::map(1:3, ~ data.frame(id = 1:500, a = rnorm(500), b = rnorm(500)) \%>\%
    bind_rows(
        data.frame(id = 501:1000, a = rnorm(500, mean = 2, sd = 1), b = rnorm(500, mean = -2, sd = 1))
    )) \%>\% setNames(1:3)
models <- mldpEHR.cv_train_stitch_outcome(0, predictor, target_list, feature_list, q_thresh = 0.5)
follow_time <- c(list(target \%>\% mutate(time_in_system = 5)), purrr::map(target_list, ~ .x \%>\%
    select(id, sex, target_class) \%>\%
    mutate(time_in_system = 5)))
markov <- mldpEHR.mortality_markov(models, follow_time, 5, 5, qbins = seq(0, 1, by = 0.25))
prob <- purrr::map2_df(markov, names(markov), ~
    as_tibble(.x$model[[1]], rownames = "sbin") \%>\%
        mutate(sex = 0, model = .y) \%>\%
        bind_rows(as_tibble(.x$model[[2]], rownames = "sbin") \%>\% mutate(sex = 1, model = .y))) \%>\%
    mutate(sbin = factor(sbin, levels = c(1:4, "dead")))

ggplot(prob, aes(x = sbin, y = dead, colour = factor(sex), group = factor(sex))) +
    geom_point() +
    geom_line() +
    facet_wrap(~model, nrow = 1) +
    theme_bw()

}
